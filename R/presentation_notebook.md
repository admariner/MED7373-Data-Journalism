# An introduction to R and coding (MED7373 Data Journalism notes)

This notebook documents the code used in the MED7373 Data Journalism class workshop introducing R.

We start by introducing **variables**. A variable is something you create in R to hold some information. It can be anything from a single number or word to an enormous table.

The key point of a variable is that they can *vary*: you can change a variable (for example, increasing an age by 1 or adding a row to a table).

To create a variable you give it a name and then **assign** it a value using the `<-` characters. Anything to the right of those characters will be used to create the value. 

In the code chunk below we create two variables. The first contains a **string** of **characters** (text) and the second contains a number. Strings and numbers are the two most common **classes** of object in R and programming generally.

I've added a **comment** before each line of code. Each comment starts with a hash sign which means the line doesn't 'run' like normal lines of code.

```{r}
#create a character variable
thisismyname <- "Paul"
#create a numeric variable
thisismyage <- 24
```

Note that the string needs to have quotation marks, but numbers do not.

Once those two lines of code have been run (you can use the green 'play' button in the upper right corner of a code chunk to run it) then the variables should appear in the **Environment** in the upper right corner of RStudio. This is how you know it's worked.

## Checking the class of a variable

We can check the class of a variable using `class()`, putting the name of the variable inside the brackets. Below we check the class of the two variables we created.

```{r}
#check the class of each variable
class(thisismyname)
class(thisismyage)
```

Note that the type of class an object is determines that you can do with it. Obviously you cannot perform mathematical calculations with character class objects, but you also cannot combine numbers with text. This is what happens when you try to do that:

```{r}
#attempt to add the two variables together
thisismyname+thisismyage
```



## Data objects in R

R works with a number of different types of **data object**, so you may come across references to working with different types in literature and tutorials, but the two main ones you need to know about are **data frames** and **vectors**.

When you import data into R using the most commonly used methods it will create a data frame variable. It's just a type of table.

A vector, meanwhile, is a type of list where all the items are the same type of data. 

**Each column of a data frame is a vector**. This means it will decide whether to treat all values in a column as numbers, or text, or perhaps Booleans (`TRUE` or `FALSE` values). 

Unlike tables in Excel, or even data frames in Python, you cannot have a column with text *and* numbers. If you do, R will convert the numbers into text - a process called **coercion**. If that's a problem, there are ways of fixing it, but we won't cover it here.

## Using functions

Like Excel, programming languages have built-in functions. We've used one already - `class()`. Others include `mean()` and `sum()`

Two useful functions when dealing with data are `read.csv()`, and `summary()` - we'll use them next.

First, we need some data.

Go to https://www.theipsa.org.uk/mp-staffing-business-costs/annual-publications and download the two most recent CSV files for MPs' expenses - you'll find them under the 'Individual Business Costs' section. 

They will need to be in the same folder as your R project. So either download them directly to that folder, or once you've downloaded them, move them there.

You should be able to see them in the *Files* window in the bottom right corner of RStudio.

Now we can import one using the `read.csv()` function, storing it in a new variable, and use the `summary()` function to get an overview of it.

```{r}
#import the file at the given location, and put it in a variable
expensesdf <- read.csv("individualBusinessCosts_23_24.csv")
#run the summary() function on that variable
summary(expensesdf)
```
## Reading the output of summary()

There's a lot of information generated by that `summary()` function. For each column it gives us an overview:

* If the column is numeric it gives us the minimum, maximum, mean, median values and the values for the first and third quartile. 
* If the column contains text values it gives us the number of items (`Length`) and the type of column (**character**).

## Drilling down to one column

We can also apply these functions to an individual column - or *field*, as it's sometimes called. 

You can drill down to specific columns in a data frame by adding a `$` sign after the data frame name, and then typing the column name. Helpfully, as soon as you type `$` after a data frame, RStudio will bring up a list of column names.

Below we apply the `summary()` function to get a summary of just one column, and the `class()` function to find out what class another column is.

```{r}
#show a summary of the Amount.Claimed column
summary(expensesdf$Amount.Claimed)
#show the class of the Category column
class(expensesdf$Category)
```

## Columns are **vectors**

Note that `class()` here tells us the class of the information *inside* the column. 

But the column itself is a type of object called a **vector**. 

A vector is just a type of list: in our data frame each column is a list (vector) of items. 

We can confirm this by using another function: `is.vector()`

```{r}
#check if an object is a vector
is.vector(expensesdf$Year)
```

## Generating a table of unique values

For a better overview of a column of text (or **character vector** in the jargon of R), we can use the `table()` function.

```{r}
#generate a table of unique values in one column
table(expensesdf$Category)
```
This works like a pivot table: it will count how many entries there are for each unique value in the column.

## Storing a table as a data frame

We can store the results of that in a new variable - but it will not be a data frame. 

To change it to a data frame we can use another function - `data.frame()` - below is the code showing how that can be done.

```{r}
#generate a table of unique values in one column
pivotbycategory <- table(expensesdf$Category)
#convert it to a data table
pivotbycategory <- data.frame(pivotbycategory)
```

## Merging two CSV files

R is especially useful for merging multiple datasets together. Let's now do that with the expenses data. 

First, we need to import a second CSV into a second data frame variable. The code is the same as when we imported the first CSV, but two elements need to change: the location of the CSV; and the name of the variable (otherwise we would overwrite our previous variable).

```{r}
#import the file at the given location, and put it in a variable
expensesbefore <- read.csv("individualBusinessCosts_22_23.csv")
```

Now we have two data frames - we need a function to merge them. The function `rbind()` will combine two data frames, one on top of the other.

Here's how to use it to create a new variable:

```{r}
#combine the two data frames and store in a new variable
bothyearsexpenses <- rbind(expensesbefore, expensesdf)
```

## Export a data frame as a new CSV

Once we've finished working in R, we will probably want to export a data frame so we can work with it in a spreadsheet, or share it. The `write.csv()` function will do that. It needs two ingredients: the name of the data frame variable; and a string (i.e. it needs to be in quotes) indicating the name you want to give to the new file.

Note that the CSV file can be given any name - just make sure it ends in .csv

```{r}
#write a CSV file from our variable
write.csv(bothyearsexpenses,"alltheexpenses.csv")
```

## Using functions from a package

All the functions we've used so far are **built in** to R - these are called **base R** functions.

But we can also access lots of other functions by importing a **package** of functions. 

Note: these are called **libraries** in Python and JavaScript, and even in R circles the terms package and library are ["sometimes used synonymously"](https://hbctraining.github.io/Intro-to-R-flipped/lessons/04_introR_packages.html) so if you hear it called a library, that's fine.

There are two stages to importing a package in R: first, it needs to be **installed**; and then it needs to be **activated**.

To install a package you use the function `install.packages()` with the name of the package in quotation marks inside the brackets. For example `install.packages('ggplot2')` would install the package ggplot, which has lots of functions related to data visualisation.

However, for the most-used packages there's no need to install them because they come already installed in RStudio.

To see which packages are installed, you can switch to the *Packages* tab in the bottom right quadrant in RStudio (the area where the *Files* tab is open by default).

You'll see a long list, starting with `askpass`. Each includes a tick box (most of which will be empty), a brief description, and a version number.

The tick box indicates if a package has been activated - which means its functions can be used. The `base` package, for example, is ticked, which means it is activated and those base functions can be used.

You can activate a function by ticking its box, but it's better to write a line of code that does it instead (so if it's run on a different machine or at a different time, it will do the activation for you).

The function to activate a package is `library()` - below we activate a library called `readr` which has functions relating to importing and exporting data.

```{r}
#activate the readr package
library('readr')
```

## Using a function from a package

Now we've activated that package we can use its functions.

One way to do this is to name the package and the function at the same time, with two colons between them. For example if we wanted to use the `read_csv` function from `readr`, which will import a CSV, we could write `readr::read_csv`.

Here's a line of code using that function instead of the `read.csv` function (note the period instead of underscore) from base R that we used earlier:

```{r}
#import a CSV and store in a variable
expensesdf_readr <- readr::read_csv( "individualBusinessCosts_23_24.csv")
```

We don't *have* to include the name of the package. This will work just as well:

```{r}
#import a CSV and store in a variable
expensesdf_readr <- read_csv( "individualBusinessCosts_23_24.csv")
```

Including the function name just makes it clearer both to others and to your future self that this function needs a particular package.

Most tutorials won't do this, so don't expect to see this widely, but it's a useful habit to get into in your own coding.

It also means you don't actually have to activate the package - as long as it's installed the code will work.

Oh, and you might be wondering why you'd use this `read_csv` instead of the `read.csv` function from base R. Well, there are a couple of reasons: one is that `read_csv` is [faster](https://arbor-analytics.com/post/2022-05-19-reading-in-data-quickly-in-r/#:~:text=We%20can%20see%20that%20the,to%20read%20in%20the%20data.); another is that `read.csv` has a tendency to import text columns as a **factor** data type, which most of the time we don't want. 

## Some useful boilerplate code to adapt

One of the reasons to learn code is so that you can use code created by others to solve your own problems. You don't necessarily need to understand exactly how the code works, just enough to make it work for *you*.

Here, then, are some more blocks of code you might find useful to adapt.

### Code to generate an interactive table

The first uses the library `DT` - short for data tables. This is a library which will take a data frame and render it as an interactive table that you can search, sort and filter.

If you click the **Knit** dropdown button at the top of this notebook, and choose **Knit to HTML** the HTML version of this notebook will include the JavaScript needed to create the interactivity for the table. That HTML page can then be published on a website.

```{r}
#create a searchable table
#activate the DT (data tables) library
library("DT")
#use the datatable function
#pass it the dataframe
DT::datatable(expensesdf)
```

### Code to combine all the CSVs in your folder into one

This code will combine multiple CSV files into one large one. It's very useful if you have files for lots of different time periods (e.g. combining twelve months of CSVs into one year's worth) or different areas (e.g. combining 40 different police force's crime data into a CSV that shows all police forces together).

Note that the CSVs you are combining must have the same structure: they must have the same number of columns, and the columns must be in the same order. This code will stack them on top of each other.

The code has two parts, because there are two problems to solve here: 

1. Generate a list of all CSV files
2. Combine them into one

The first problem is solved by using the `list.files()` function. This will list (in a vector object) all the files in a particular location, but it can also be told to only look for files matching a particular pattern. 

The code below does this by using something called a **regular expression** to say it only wants to list files that end in ".csv".

The second problem is solved by passing that vector of file names to the `read_csv()` function from the `readr` package, which can handle multiple files. It also includes an extra ingredient, which specifies that you want to add an extra column to each CSV called 'file_name', to store the name of each file.

```{r}
#list all CSV files in the folder
list.files(pattern="\\.csv$")
#now store that as a vector
csvfiles <- list.files(pattern="\\.csv$")
#and combine them
#id= names an extra column
allcsvs <- readr::read_csv(csvfilenames, id = "file_name")
```

### Code to create a very basic chart

The final chunk of code generates a basic chart - a histogram - based on the values in one column of a data frame.

This uses the chart creation package `ggplot2`, so we activate it in the first line. There's quite a lot going on in the other lines of code, even for a basic chart like this:

* First, we use the `ggplot()` function from `ggplot2`, and we give it the data frame that we want to visualise: `expensesdf`
* The `+` sign allows us to specify extra information like the type of chart we want to create (these are listed in the documentation and tutorials for this package): `geom_histogram()`
* That `geom_histogram()` is essentially another function which needs information about the column in the data frame that it's going to use to create the chart. It does that with `aes(x=Amount.Claimed)`

You can adapt this a little bit to work with a different dataframe, and/or a different column (it must be numeric), but to do anything more - including changing colours, chart types, backgrounds and adding labels - you'll need to start learning about the ggplot package by exploring tutorials.

```{r}
#activate the ggplot2 library
library("ggplot2")

#use the ggplot function with our dataset
ggplot2::ggplot(expensesdf) + 
  geom_histogram(
    aes(x=Amount.Claimed)) 
```

